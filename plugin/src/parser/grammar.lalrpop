use ast::*;
use lalrpop_intern::{intern, InternedString};
use parser;
use tok::Tok;

#[LALR]
grammar<'input>;

pub Program: Program = {
    Class* => Program { classes: <> }
};

Class: Class = {
    "class" <name:Id> <extends:("extends" <Id>)?> <b:@L> <blk:"{..}"> =>? {
        let members = parser::parse_members(blk, b)?;
        Ok(Class { name, extends, members })
    }
};

pub Members: Vec<Member> = {
    Member*
};

Id: InternedString = {
    OtherId => intern(<>),
};

Member: Member = {
    PrivateStruct => Member::PrivateStruct(<>),
};

PrivateStruct: PrivateStruct = {
    "struct" <name:Id> <s:@L> <fields:"{..}"> =>? {
        let fields = parser::parse_fields(fields, s)?;
        Ok(PrivateStruct { name, fields })
    }
};

pub Fields: Vec<Field> = {
    Field*
};

Field: Field = {
    <name:Id> ":" <ty:Type> => Field { name, ty },
};

Type: Type = {
    Type1,
    <h:Type1> <t:("+" <Type1>)+> => Type::Sum(Some(h).into_iter().chain(t).collect()),
};

Type1: Type = {
    Id => Type::Name(<>),
    <Id> "<" <Type*> ">" => Type::Args(<>),
    "[" <Type> "]" => Type::Array(Box::new(<>)),
};

Comma<T>: Vec<T> = {
    <h:(<T> ",")*> <t:T?> => {
        let mut h = h;
        h.extend(t);
        h
    }
};

extern {
    type Location = usize;
    type Error = ::errors::Error;
    enum Tok<'input> {
        "class" => Tok::Class,
        "struct" => Tok::Struct,
        "fn" => Tok::Fn,
        "init" => Tok::Init,
        "extends" => Tok::Extends,
        "{..}" => Tok::Block(<&'input str>),
        OtherId => Tok::Id(<&'input str>),
        ":" => Tok::Colon,
        "<" => Tok::LessThan,
        ">" => Tok::GreaterThan,
        "[" => Tok::LeftBracket,
        "]" => Tok::RightBracket,
        "(" => Tok::LeftParen,
        ")" => Tok::LeftParen,
        "+" => Tok::Plus,
    }
}
